---
layout: post
title: Understading some of Roo's magic
date: '2010-02-16T22:11:00.010-05:00'
author: Alberto
tags:
- AOP
- Spring-Roo
- Spring
- AspectJ
modified_time: '2010-02-16T22:18:02.137-05:00'
blogger_id: tag:blogger.com,1999:blog-4831432806087932521.post-6418206721564568578
blogger_orig_url: https://alberto-flores.blogspot.com/2010/02/understading-some-roos-magic.html
---

&nbsp; I must admit that I was among the many developers I know who are very skeptical about Aspect Oriented Programming (AOP).&nbsp; I've written many aspects myself, some which I now define as "<i>entry-level</i>".&nbsp; I had not seen a clear <i>use-case</i> for aspects other than the basic "<i>auditing</i>", "<i>logging</i>" or "<i>security</i>" use cases.&nbsp; So, a few months ago I started to play with one of the latest tools from SpringSource, namely <i>Spring-Roo</i>. To my surprise, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Roo</span> was not only meeting my expectations, but also made me a believer on yet another good use case for AOP.&nbsp; The use case of tooling support.&nbsp; I'll try to explain some of the magic which <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Roo</span> brings to software development using AspectJ.<br /><a name='more'></a><br />Consider for a moment the following entity:<br /><br /><pre class="brush: java">public class MyPojo {<br />  private String name;<br />}<br /></pre><br />This entity can easily be coded using any IDE, however <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Roo</span> allows you to create it with a command line shell. Once this is done, the average developer will rely on source generation features (from an IDE) to generate Setter/Getters (so as to conform with standard JavaBean conventions). This is where the concept of <i>Inter-Type Declarations </i>(<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ITD</span>) in AspectJ can be of great help.&nbsp; Consider the following aspect:<br /><pre class="brush: java">public aspect MyPojo_Entity {<br />  private Long id;<br />  private static int sequence = 0;<br />  <br />  /** <br />   * Constructor with arguments<br />   */<br />  public MyPojo.new(String name) {<br />    super();<br />    id = new Long(sequence++);<br />  }<br />   <br />  /**<br />   * ToString method.<br />   */<br />  public String MyPojo.toString() {<br />    return "Sequence: " + id;<br />  }<br />}<br /></pre><br />You can see that this aspect is now introducing&nbsp; a new constructor as well as a <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">toString()</span> method for the entity <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">MyPojo</span>. The resulting bytecode will now have a <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">toString()</span> method which can be called anywhere. Also, it will enforce the constructor to be called with an argument. This notion of <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ITD</span> can be used to introduce new methods as well as private properties. Now, let's finish this aspect:<br /><br /><pre class="brush: java">public privileged aspect MyPojo_Entity {<br />  private Long MyPojo.id; <br />  private static int sequence = 0;<br /><br />  /**<br />   * Constructor<br />   */ <br />  public MyPojo.new(String name) {<br />    super();<br />    this.name = name;<br />    this.id = new Long(sequence++);<br />  }<br /> <br />  /**<br />   * Retrieves the id of this pojo<br />   */ <br />  public Long MyPojo.getId() {<br />    return id;<br />  }<br /><br />  /**<br />   * Retrieves the name of this pojo<br />   * @return the name of this pojo.<br />   */ <br />  public String MyPojo.getName() {<br />    return this.name;<br />  }<br /> <br />  /**<br />   * Sets the name of this pojo.<br />   * @param name the name to set.<br />   */ <br />  public void MyPojo.setName(String name) {<br />    this.name = name;<br />  }<br /> <br />  /**<br />   * Default toString() method.<br />   */ <br />  public String MyPojo.toString() {<br />    return "Pojo [id="+this.id+"]: " <br />          + this.name;<br />  }<br />}<br /></pre><br />As you can see,&nbsp; we not only introduced the methods needed to make <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">MyPojo</span> compliant with JavaBean standards, but also added more attributes and methods (e.g. to help persisting it). Furthermore, if you look closer, the aspect definition now uses the <b style="color: #660000;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">privileged</span></b> keyword. A <b style="color: #660000;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">privileged</span></b> aspect basically grants access to private attributes and methods of the class in question, thus we can use the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">this.name</span> for this purposes without problems.<br /><br />If you look at the generated code from <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Roo</span>, this is exactly how <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Roo</span> makes magic happen. In fact, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Roo</span> also injects an <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">EntityManager</span> as well as <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">hashCode()</span>, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">equals()</span>, as well as other methods based on the<i> cross-cutting</i> concern. It's defitenetly worth checking out <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Roo</span> for a good test-drive, not only of the tool, but how to use AspectJ effectively.